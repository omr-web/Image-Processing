/**********************************************************
 The original copy of the code can be found at http://web.eecs.utk.edu/~mkarakay/courses_files/testfiles.zip
 and it is modified for ELM463/667

 * Image.cpp - the image library which implements
 *             the member functions defined in Image.h
 *
 * Author: Hairong Qi, ECE, University of Tennessee
 *
 * Created: 02/05/02
 *
 * Copyright (C) hqi@utk.edu
 **********************************************************/

#include "Image.h"
#include <iostream>
#include <iomanip>
#include <cmath>
#include <complex>  // LAB3 i√ßin eklendi
//#include <bits/stdc++.h>
using namespace std;
#define pi 3.141592
/**
 * Default constructor.
 */
 using namespace std ;
Image::Image() {
  image = NULL;
  nrows = 0;
  ncols = 0;
  maximum = 255;
  //createImage(0, 0);
}

/**
 * Constructor for grayscale images.
 * @param nrows Numbers of rows (height).
 * @param ncols Number of columns (width).
 * @return The created image.
 */
Image::Image(int nRows, int nCols) {
  if (nRows<=0 || nCols<=0) {
    cout << "Image: Index out of range.\n";
    exit(3);
  }
  image = NULL;
  createImage(nRows, nCols);
}

/**
 * Copy constructor.
 * @param img Copy image.
 * @return The created image.
 */
Image::Image(const Image &img) {
  int rows, cols;

  image = NULL;
  nrows = img.getRow();
  ncols = img.getCol();
  createImage(nrows, ncols);             // allocate memory

  for (rows=0; rows < nrows; rows++)
    for (cols=0; cols < ncols; cols++)
		image[rows * ncols + cols] = img(rows, cols);
}

/**
 * Destructor.  Frees memory.
 */
Image::~Image() {
  if (image)
    delete [] image;       // free the image buffer
}






/**
 * Allocate memory for the image and initialize the content to be 0.
 */
void Image::createImage() {

  if (image != NULL)
    delete [] image;

  maximum = 255;

  image = (float *) new float [nrows * ncols];
  if (!image) {
    cout << "CREATEIMAGE: Out of memory.\n";
    exit(1);
  }

  initImage();
}


/**
 * Allocate memory for the image and initialize the content to be zero.
 * @param r Numbers of rows (height).
 * @param c Number of columns (width).
 */
void Image::createImage(int numberOfRows, int numberOfColumns) {

  if (image != NULL)
    delete [] image;

  nrows = numberOfRows;
  ncols = numberOfColumns;
  maximum = 255;

  image = (float *) new float [nrows * ncols];
  if (!image) {
    cout << "CREATEIMAGE: Out of memory.\n";
    exit(1);
  }

  initImage();
}

/**
 * Initialize the image.
 * @para init The value the image is initialized to. Default is 0.0.
 */
void Image::initImage(float initialValue) {
  int i;

  for (i = 0; i < nrows * ncols; i++)
    image[i] = initialValue;
}

/**
 * Returns the total number of rows in the image.
 * @return Total number of rows.
 * \ingroup getset
 */
int Image::getRow() const {
  return nrows;
}

/**
 * Returns the total number of columns in the image.
 * @return Total number of columns.
 * \ingroup getset
 */
int Image::getCol() const {
  return ncols;
}

/**
 * Returns the maximum pixel value of a gray-level image.
 * @return The intensity of that pixel.
 * \ingroup getset
 */
float Image::getMaximum() const {
  int i, j;
  float maxi=-10000;


  for (i=0; i<nrows; i++)
    for (j=0; j<ncols; j++)
      if (maxi < image[i*ncols+j])
	maxi = image[i*ncols+j];

  return maxi;
}


/**
 * Returns the minimum pixel value of the image.
 * @return The minimum pixel value.
 * \ingroup getset
 */
float Image::getMinimum() const {
  int i, j;
  float mini=10000;

  for (i=0; i<nrows; i++)
    for (j=0; j<ncols; j++)
      if (mini > image[i*ncols+j])
	mini = image[i*ncols+j];

  return mini;
}



/**
 * Returns the pixel value at rows, cols
 * @return The pixel value
 * \ingroup getset
 */
float Image::getPix(int rows, int cols) {
  return image[rows * ncols + cols];
}


/**
 * Returns the image.
 * @return a gray-scale image
 * \ingroup getset
 */
Image Image::getImage() const {
  Image temp;
  int rows, cols;

  temp.createImage(nrows, ncols);   // temp is a gray-scale image
  for (rows = 0; rows < nrows; rows++)
    for (cols = 0; cols < ncols; cols++)
      temp(rows, cols) = image[rows * ncols + cols];

  return temp;
}

/**
 * Sets the total number of rows in an image.
 * @param r Total number of rows.
 * \ingroup getset
 */
void Image::setRow(int numberOfRows) {
  nrows = numberOfRows;
}

/**
 * Sets the total number of columns in an image.
 * @param c Total number of columns.
 * \ingroup getset
 */
void Image::setCol(int numberOfColumns) {
  ncols = numberOfColumns;
}


/**
 * Sets the pixel value at rows,cols.
 * @param row and col index.
 * \ingroup getset
 */
void Image::setPix(int rows, int cols, float value) {
  image[rows * ncols + cols] = value;
}


/**
 * Sets the image given a grayscale image.
 * \ingroup getset
 */
void Image::setImage(Image &img) {
  int rows, cols;

  for (rows = 0; rows < nrows; rows++)
    for (cols = 0; cols < ncols; cols++)
      image[rows * ncols + cols] = img(rows, cols);
}

/**
 * Overloading () operator
 * \ingroup overload
 * @param i Row
 * @param j Column
 */
float & Image::operator()(int rows, int cols) const {
  return image[rows * ncols + cols];
}

/**
 * Overloading = operator.
 * \ingroup overload
 * @param img Image to copy.
 * @return Newly copied image.
 */
const Image Image::operator=(const Image& img) {
  int rows, cols;

  if (this == &img)
    return *this;

  nrows = img.getRow();
  ncols = img.getCol();
  createImage(nrows, ncols);

  for (rows = 0; rows < nrows; rows++)
    for (cols = 0; cols < ncols; cols++)
	(*this)(rows, cols) = img(rows, cols);

  return *this;
}

/**
 * Overloading + operator.
 * \ingroup overload
 * @param img Image to add to specified image.
 * @return Addition of the two images.
 */
Image Image::operator+(const Image& img) const {
  int i, j, nr, nc;
  Image temp;

  nr = img.getRow();
  nc = img.getCol();

  if (nr != nrows || nc != ncols) {
    cout << "operator+: "
         << "Images are not of the same size or type, can't do addition\n";
    exit(3);
  }
  temp.createImage(nrows, ncols);

  for (i=0; i<nrows; i++)
    for (j=0; j<ncols; j++)
        temp(i,j) = image[i*ncols+j] + img(i,j);

  return temp;
}

/**
 * Overloading - operator.
 * \ingroup overload
 * @param img Image to subtract from specified image.
 * @return Subtraction of the two images.
 */
Image Image::operator-(const Image &img) const {
   int i, j, nr, nc;
  Image temp;

  nr = img.getRow();
  nc = img.getCol();

  if (nr != nrows || nc != ncols) {
    cout << "operator-: "
         << "Images are not of the same size or type, can't do subtraction\n";
    exit(3);
  }
  temp.createImage(nrows, ncols);

  for (i=0; i<nrows; i++)
    for (j=0; j<ncols; j++)
        temp(i,j) = image[i*ncols+j] - img(i,j);

  return temp;
}

/**
 * Overloading * operator.  This function does pixel by pixel multiplication.
 * \ingroup overload
 * @param img Image to multiply with specified image.
 * @return Multiplication of the two images.
 */
Image Image::operator*(const Image &img) const {
  int i, j, nr, nc;
  Image temp;

  nr = img.getRow();
  nc = img.getCol();

  if (nr != nrows || nc != ncols) {
    cout << "operator*: "
         << "Images are not of the same size or type, can't do multiplication\n";
    exit(3);
  }
  temp.createImage(nrows, ncols);

  for (i=0; i<nrows; i++)
    for (j=0; j<ncols; j++)
        temp(i,j) = image[i*ncols+j] * img(i,j);

  return temp;
}

/**
 * Overloading / operator.  This function does pixel by pixel division.
 * Specified image is the dividend.
 * \ingroup overload
 * @param img Image to be divided (divisor).
 * @return Quotient of the two images.
 */
Image Image::operator/(const Image &img) const {
  int i, j, nr, nc;
  Image temp;

  nr = img.getRow();
  nc = img.getCol();

  if (nr != nrows || nc != ncols) {
    cout << "operator/: "
         << "Images are not of the same size or type, can't do division\n";
    exit(3);
  }
  temp.createImage(nrows, ncols);

  for (i=0; i<nrows; i++)
    for (j=0; j<ncols; j++)
        temp(i,j) = image[i*ncols+j] / ( img(i,j) + 0.001 );

  return temp;
}


/**
 * Overloading << operator.  Output the image to the specified destination.
 * \ingroup overload
 * @param out The specified output stream (or output destination).
 * @param img Image to be output.
 * @result Output image to the specified file destination.
 */
ostream & operator<<(ostream &out, Image &img) {
  int rows, cols;


    for (rows = 0; rows < img.getRow(); rows++) {
      for (cols = 0; cols < img.getCol(); cols++)
        out << setw(4) << img(rows, cols) << ' ';
      out << endl;
    }

  return out;
}

/**
 * Overloading / operator.  The left operand is the image and the right
 * is the dividend (a double point number). Each pixel in the image is
 * divided by the double point number.
 * \ingroup overload
 * @param img Image as the left operand.
 * @param val A double point number as the right operand.
 * @result Image divided by a double point number.
 */
Image operator/(Image &img, double val) {
  int i, j, nr, nc;
  Image temp;

  nr = img.getRow();
  nc = img.getCol();
  temp.createImage(nr, nc);

  for (i=0; i<nr; i++)
    for (j=0; j<nc; j++)
        temp(i,j) = img(i,j) / val;

  return temp;
}

/**
 * Overloading * operator.  The left operand is the image and the right
 * is a double point number. Each pixel in the image is multiplied by the
 * double point number.
 * \ingroup overload
 * @param img Image as the left operand.
 * @param s A double point number as the right operand.
 * @result Image multiplied by a double point scalar.
 */
Image operator*(Image &img, double s) {
  int i, j, nr, nc;
  Image temp;

  nr = img.getRow();
  nc = img.getCol();
  temp.createImage(nr, nc);

  for (i=0; i<nr; i++)
    for (j=0; j<nc; j++)
        temp(i,j) = img(i,j) * s;

  return temp;
}


/**
 * Overloading + operator.  The left operand is the image and the right
 * is a double point number. Each pixel in the image is added by the
 * double point number.
 * \ingroup overload
 * @param img Image as the left operand.
 * @param s A double point number as the right operand.
 * @result Image add a double point scalar.
 */
Image operator+(Image &img, double s) {
  int i, j, nr, nc;
  Image temp;

  nr = img.getRow();
  nc = img.getCol();
  temp.createImage(nr, nc);

  for (i=0; i<nr; i++)
    for (j=0; j<nc; j++)
        temp(i,j) = img(i,j) + s;

  return temp;
}

/**
 * Overloading - operator.  The left operand is the image and the right
 * is a double point number. Each pixel in the image is subtracted by the
 * double point number.
 * \ingroup overload
 * @param img Image as the left operand.
 * @param s A double point number as the right operand.
 * @result Image subtract a double point scalar.
 */
Image operator-(Image &img, double s) {
  int i, j, nr, nc;
  Image temp;

  nr = img.getRow();
  nc = img.getCol();
  temp.createImage(nr, nc);

  for (i=0; i<nr; i++)
    for (j=0; j<nc; j++)
        temp(i,j) = img(i,j) - s;

  return temp;
}

/**
 * Read image from a file
 * @param fname The name of the file
 * @return An Image object
 */
  void Image::readImage(char *fname) {
  ifstream ifp;
  char dummy[80];
  unsigned char *img;
  int rows, cols;
  int nRows, nCols, nt, maxi;

  ifp.open(fname, ios::in | ios::binary);

  if (!ifp) {
    cout << "readImage: Can't read image: " << fname << endl;
    exit(1);
  }

  // identify image format
  ifp.getline(dummy, 80, '\n');

  if (dummy[0] == 'P' && dummy[1] == '5')
     ;
  else {
    cout << "readImage: Can't identify image format." << endl;
    exit(1);
  }

  // skip the comments
  ifp.getline(dummy, 80, '\n');

  while (dummy[0] == '#') {
    ifp.getline(dummy, 80, '\n');
  }

  // read the row number and column number
  sscanf(dummy, "%d %d", &nCols, &nRows);

  // read the maximum pixel value
  ifp.getline(dummy, 80, '\n');
  sscanf(dummy, "%d", &maxi);
  if (maxi > 255) {
    cout << "Don't know what to do: maximum value is over 255.\n";
    exit(1);
  }

  if (image != NULL)
  delete [] image;

  nrows = nRows;
  ncols = nCols;
  maximum = 255;

  // read the image data
  img = (unsigned char *) new unsigned char [nRows * nCols];
  if (!img) {
    cout << "READIMAGE: Out of memory.\n";
    exit(1);
  }
  image = (float *) new float [nRows * nCols];
  if (!image) {
    cout << "READIMAGE: Out of memory.\n";
    exit(1);
  }

    ifp.read((char *)img, (nRows * nCols * sizeof(unsigned char)));

    for (rows = 0; rows < nRows; rows++)
      for (cols = 0; cols < nCols; cols++)
          image[rows * nCols + cols] = (float) img[rows * nCols + cols];

  ifp.close();

  delete [] img;
}


/**
 * Write image buffer to a file.
 * @param fname The output file name.
 */
void Image::writeImage(char *fname, bool flag) {
  ofstream ofp;
  int i, j;
  int nRows, nCols, nt;
  unsigned char *img;

  ofp.open(fname, ios::out | ios::binary);

  if (!ofp) {
    cout << "writeImage: Can't write image: " << fname << endl;
    exit(1);
  }


  ofp << "P5" << endl;
  ofp << ncols << " " << nrows << endl;


  ofp << 255 << endl;



  // convert the image data type back to unsigned char
  img = (unsigned char *) new unsigned char [nrows * ncols];
  if (!img) {
    cout << "WRITEIMAGE: Out of memory.\n";
    exit(1);
  }

  float maxi = getMaximum();
  float mini = getMinimum();


    for (i = 0; i< nrows; i++)
      for (j = 0; j < ncols; j++) {
	  // rescale if the flag is set
	  if ((maxi != mini) && flag == true)
	    img[i * ncols + j] = (unsigned char)  ((image[i * ncols + j]-mini)/(float)(maxi-mini)*255.0);
	  // any intensity that is larger than the maximum would be set as maximum
	  else if (image[i * ncols + j] > 255)
	    img[i * ncols + j] = 255;
	  else if (image[i * ncols + j] < 0)
	    img[i * ncols + j] = 0;
	  else
	    img[i * ncols + j] = (unsigned char)  image[i * ncols + j];
      }

    ofp.write((char *)img, (nrows * ncols * sizeof(unsigned char)));


  ofp.close();
  delete [] img;
}




// YOUR FUNCTIONS

/**
 * Returns the image.
 * @return a gray-scale image
 * \ingroup getset
 */
Image Image::thresholdImage(float thresholdValue, float lowValue, float highValue) {
  Image temp;
  int rows, cols;

  temp.createImage(nrows, ncols);   // temp is a gray-scale image
  for (rows = 0; rows < nrows; rows++)
    for (cols = 0; cols < ncols; cols++)
      if (image[rows * ncols + cols] <= thresholdValue)
	temp(rows, cols) = lowValue;
      else
	temp(rows, cols) = highValue;


  return temp;
}
////////////////////////////////////////////////////////////////////// Lab i√ßin yazƒ±lan fonksiyonlar

///////////////// 1. SORU ƒ∞√áƒ∞N /////////////////////////////////
void Image::Adjust_Image() {
    int i,j;
    setPix(0,0,50); // f√∂yde istenildiƒüi gibi en soldaki pixel deƒüeri 50 olarak atandƒ±

    /* ƒ∞lk satƒ±r olu≈üturuldu */
    for(i=1; i<3; i++)
    {
        setPix(0,i,50+i);
    }

    /* ƒ∞lk s√ºtun olu≈üturuldu*/
    for(i=1; i<10; i++)
    {
        setPix(i,0,50+i);
    }


    /* ƒ∞lk satƒ±r ve ilk s√ºtun dƒ±≈üƒ±nda kalan pixel deƒüerleri belirlendi*/
    for(i=0; i<10; i++)
    {
        for(j=0; j<15; j++)
        {
            setPix(i,j,getPix(i,0)+j); // her satƒ±rda bulunan pixel deƒüeri ilk s√ºtundaki pixel deƒüeri (image.getPix(i,0)) ve yer bilgisine (j) g√∂re olu≈üturuldu
        }

    }
}
////////////////////////////////////////2. SORU ƒ∞√áƒ∞N /////////////////////////////////////////
/*
Fonksiyon tam sayƒ± bir deƒüeri girdi olarak alƒ±r. Bu girdi 0 ise g√∂r√ºnt√ºn√ºn boyutu
iki kat b√ºy√ºyecek girdi 1 ise g√∂r√ºnt√ºn√ºn boyutu iki kat k√º√ß√ºlecek anlamƒ±na gelir.
*/
/*
Fonksiyonun √áalƒ±≈üma mantƒ±ƒüƒ±:
g√∂r√ºnt√ºn√ºn boyutlarƒ± arttƒ±rƒ±lmak istendiƒüinde normal boyuttaki g√∂r√ºnt√ºn√ºn pixel deƒüerleri birden √ßok kez kullanƒ±lmƒ±≈ütƒ±r. √ñrneƒüin (0,2)
koordinatlarƒ±ndaki pixel deƒüeri, (0,3) (0,2),(2,1) ve (1,2) pixel deƒüerlerine yazƒ±lmƒ±≈ütƒ±r. Bu sayede g√∂r√ºnt√ºn√ºn boyutlarƒ± b√ºy√ºt√ºlm√º≈ü√ºt√ºr.

G√∂r√ºnt√ºn√ºn boyutlarƒ± azaltƒ±lmak istenilidƒüinde, olu≈üturulacak g√∂r√ºnt√ºn√ºn daha az pixel deƒüerine sahip olacaƒüƒ± i√ßin orijinal
g√∂r√ºnt√ºdeki bazƒ± pixel deƒüerleri atlanarak alƒ±nmƒ±≈ütƒ±r.

*/

Image Image::  Change_Dimension(int a) {
    int i=0,j=0;
    int x,y;

    if(a==0) {
       Image image_out (getRow()*2 ,getCol()*2); // boyutlarƒ± orijinalinden iki kat fazla olan obje olu≈üturuldu
        for(x=0;x<getRow();x=x+1) {
                for(y=0;y<getCol();y=y+1) {
                    /* Yukarƒ±daki a√ßƒ±klamada bahsedilen ilgili pixel koordinatlarƒ±nƒ±n doldurulmasƒ±  */
                    image_out.setPix(i,j,getPix(x,y)); // pixel deƒüerinin koyulmasƒ± hedeflenen asƒ±l yeri
                    image_out.setPix(i,j+1,getPix(x,y)); // pixel deƒüerinin asƒ±l koyulmasƒ± gereken koordinatƒ±n bir saƒüƒ±
                    image_out.setPix(i+1,j,getPix(x,y)); //ixel deƒüerinin asƒ±l koyulmasƒ± gereken koordinatƒ±n bir satƒ±r a≈üaƒüƒ±sƒ±
                    if(i!=0) // (0,0) koordinatƒ± ise 4 farklƒ± koordinatƒ± doldurmaya gerek yoktur. Bu if (0,0) pixel koordinatƒ±nƒ± kontrol etmek i√ßin vardƒ±r.
                        image_out.setPix(i+1,j-1,getPix(x,y)); //ixel deƒüerinin asƒ±l koyulmasƒ± gereken koordinatƒ±n sol √ßaprazƒ±
                    j=j+2;
                }
            i=i+2;
            j=0;
        }
       return image_out;
    }

    else  {
        Image image_out (getRow()/2 ,getCol()/2);// boyutlarƒ± orijinalinden iki kat k√º√ß√ºk (yarƒ±sƒ± kadar) olan obje olu≈üturuldu
        for(x=0;x<getRow();x=x+2) { // orijinal g√∂r√ºnt√ºden pixel deƒüerleri bir atlanarak alƒ±nacaƒüƒ± i√ßin x ve y artƒ±≈üƒ± 2'≈üer 2'≈üer yapƒ±lmƒ±≈ütƒ±r.
                for(y=0;y<getCol();y=y+2) {
                    /* Yukarƒ±da bahsedildiƒüi gibi ilgili pixel koordinat deƒüerleri orijinal g√∂r√ºnt√ºden alƒ±nmƒ±≈ütƒ±r. Fakat orijinal g√∂r√ºnt√ºden bazƒ± pixel deƒüerleri alƒ±nmamƒ±≈ütƒ±r (Boyut k√º√ß√ºld√ºƒü√º i√ßin). */
                    image_out.setPix(i,j,getPix(x,y));
                    j=j+1;
                }
            i=i+1;
            j=0;
        }
    return image_out;
    }

}
/////////////////////////////////////////////////// LAB-1 FONKSƒ∞YONLARI /////////////////////////////////////////////////////////////
/*
_ImageNegatives Fonksiyonu: Bu fonksiyon giri≈ü g√∂r√ºnt√ºs√ºn√ºn pixel deƒüerlerinin tam tersini alƒ±r belirli koordinatta ki pixel deƒüeri r ise bu fonksiyon
sonunda bu koordinattaki g√ºncel pixel deƒüeri 255-r olacaktƒ±r.

*/
Image Image:: _ImageNegatives() {
    int i ,j;
    Image temp(getRow(),getCol());
    /* Her koordinattaki pixel deƒüerinin tersi alƒ±nƒ±r*/
    for (i=0;i<getRow();i++) {
        for(j=0;j<getCol();j++) {
            temp.setPix(i,j,(255-getPix(i,j)));
        }
    }
/* return deƒüeri olarak bir Image objesi d√∂nd√ºr√ºr. */
return temp ;
}

/*
_ImageLog() fonksiyonu:
g√∂r√ºnt√º √ºzerinde pixel deƒüerlerini ayrƒ± ayrƒ± iyile≈ütirir. Bu iyile≈ütirme i≈ülemeni logaritma fonksiyonu ile yapar.
s= c*log10(r)
s deƒüerleri logaritma alƒ±ndƒ±ƒüƒ± i√ßin doƒüal olarak √ßok k√º√ß√ºk bir aralƒ±kta deƒüi≈üme g√∂sterecektir. Bunun i√ßin g√∂r√ºnt√º pizel deƒüerlerini
(0-255) arasƒ±nda √∂l√ßeklendirmek gerekir.c katsayƒ±sƒ± 1 olarak alƒ±nmƒ±≈ütƒ±r.

 */
Image Image:: _ImageLog() {
    int i ,j;
    double c =-10 ;
    Image temp(getRow(),getCol());
    for (i=0;i<getRow();i++) {
        for(j=0;j<getCol();j++) {
            temp.setPix(i,j,(255/2.4)*(c*log10(getPix(i,j)+1))); // log fonksiyonu uygulanmasƒ± ve √∂l√ßekleme i≈üleminin yapƒ±lmasƒ±
        }
    }

return temp ;
}
/*
 _ImageGama Fonksiyonu: Giri≈ü g√∂r√ºnt√ºs√ºn√ºn her bir pixel deƒüerini ayrƒ± ayrƒ± r=c* (r^gama) formul√º aracƒ±lƒ±ƒüyla
 g√ºnceller. c katsayƒ±sƒ± 1 olarak alƒ±nmƒ±≈ütƒ±r. Gama deƒüeri ise girdi olarak alƒ±nmƒ±≈ütƒ±r. Girilecek gama deƒüeri 0<gama<1 aralƒ±ƒüƒ±nda
 olmak zorundadƒ±r. Form√ºl sonucunda elde edilen deƒüerler 0-255 aralƒ±ƒüƒ±nda √∂l√ßeklendirilmi≈ütir.

*/
Image Image:: _ImageGama(double gama ) {
    int i ,j; // d√∂ng√º deƒüi≈ükenleri
    int c =1 ; // form√ºl i√ßin katsayƒ± deƒüeri
    int scale_value; // √∂l√ßek katsayƒ±sƒ±
    /* √ñl√ßek katsayƒ±sƒ±nƒ±n yuvarlama i≈üleminin ger√ßekle≈ütirilmesi */
    if(gama==0.6)
        scale_value=28;  // 27.79 yuvarlandƒ±
    else if (gama==0.4)
        scale_value=9; // 9.17 yuvarlandƒ±
    else if(gama==0.5)
        scale_value=16;
    else
        scale_value=5; // 5.27 den yuvarlandƒ±

    /*D√∂nd√ºr√ºlecek obje giri≈ü g√∂r√ºnt√ºs√ºn√ºn satƒ±r ve s√ºtun sayƒ±larƒ±na g√∂re olu≈üturuldu */
    Image temp(getRow(),getCol());

    for (i=0;i<getRow();i++) {
        for(j=0;j<getCol();j++) {
            temp.setPix(i,j,(255/scale_value)*(c*pow(getPix(i,j),gama))); // yeni pixel deƒüerinin gamalƒ± form√ºle g√∂re olu≈üturulmasƒ±
        }
    }

return temp ;
}
/*
Bir √∂nceki fonksiyon ile tamamen aynƒ± i≈ülem ve aynƒ± form√ºl uygulanmaktadƒ±r sadece bu fonksiyona girilecek gama deƒüerinin 1 den b√ºy√ºk
olmasƒ± gerekmektedir.
*/
Image Image:: _ImageGama_BiggerThanOne(double gama ){
    int i ,j;
    int c =1 ;
    double scale_value;  // uint64 iken √ßalƒ±≈ümadƒ± neden acaba? (√∂l√ßeklendirme kat sayƒ±sƒ±nƒ±n double olarak tanƒ±mlanmasƒ± √∂nemli)

    if(gama==3)
        scale_value=16581375;
    else if (gama==4)
        scale_value=4228250625;
    else
        scale_value=1078203903000;

    Image temp(getRow(),getCol());

    for (i=0;i<getRow();i++) {
        for(j=0;j<getCol();j++) {
            temp.setPix(i,j,(255/scale_value)*(c*pow(getPix(i,j),gama))); // yeni pixel deƒüerinin gamalƒ± form√ºle g√∂re olu≈üturulmasƒ±
        }
    }
return temp ;
}

/*
Kullanƒ±cƒ±nƒ±n gireceƒüi sayƒ±ya g√∂re bir filtre olu≈üturur. Bu filtreyi her bir pixel deƒüeri ve pixel deƒüerlerinin kom≈üularƒ±na uygular.
Filtre uygulandƒ±ƒüƒ± pixel deƒüerlerinin ortalamasƒ±nƒ± alƒ±r ve deƒüi≈ütirmesi gereken pixel deƒüerini bu bulduƒüu ortalama deƒüer ile g√ºnceller.

*/


Image Image:: _Average_Filter (int a) {

   Image temp(getRow(),getCol()) ; // yeni g√∂r√ºnt√º i√ßin obje olu≈üturuldu



   int filter [a][a]; // filtre girilen a deƒüerine g√∂re olu≈üturuldu
   int i,j ; // g√∂r√ºnt√º d√∂necek
   int x,y;  // filtre i√ßin
   int k,m;
   int l,n;
   int gecici_toplam=0; // filtrede bulunan pixel deƒüerlerinin toplanmasƒ± i√ßin.
    /*k ve m deƒüerleri filtre arrayinin deƒüerlerinin doldurulmasƒ± i√ßin kullanƒ±lmƒ±≈ütƒ±r. */
   k= (-1)*((a-1)/2);
   m=(-1)*((a-1)/2);
    /* pixel(i,j) deƒüeri filtrenin ortasƒ±na yerle≈ütirmi≈ütir. 5x5 lik bir filtrede √∂rneƒüin 2,2 pixel koordinatƒ± oluyor
        filtrenin geri kalan koordinatlarƒ±nƒ± doldurabilmek i√ßin iki adet for d√∂ng√ºs√º daha yapƒ±lmƒ±≈ütƒ±r. k ve m deƒüerlerinde g√ºncellemeler
        yapƒ±larak bu i≈ülem saƒülanmƒ±≈ütƒ±r.Doldurulan filtre koordinatlarƒ±ndaki deƒüerler daha sonra toplanƒ±p ortalamalarƒ± alƒ±nmƒ±≈ütƒ±r.
    */
   for(i=0;i<getRow();i++){
        for(j=0;j<getCol();j++){
            for(x=0;x<a;x++){
                for(y=0;y<a;y++){
                    if((i+k)<0 || (i+k)>getRow() || (j+m)<0 || (j+m)> getCol()) // k√∂≈üe veya filtrenin boyutlarƒ±na g√∂re ,filtre g√∂r√ºnt√ºn√ºn dƒ±≈üƒ±na ta≈üabilir. B√∂yle durumlarda filtre koordinatƒ±na 0 deƒüeri yazƒ±lmƒ±≈ütƒ±r.
                        filter[x][y]=0;
                    else // herhangi bir ta≈üma yoksa ilgili koordinatta g√∂r√ºnt√ºn√ºn pixel deƒüeri mevcutsa else e girer.
                        filter[x][y]=getPix(i+k,j+m);
                    m=m+1;
                }
                m=(-1)*((a-1)/2);
                k=k+1;
            }
          k= (-1)*(a-1)/2;
          m= (-1)*(a-1)/2;
          /*Filtre pixel deƒüerlerinin toplanmasƒ± */
          for(l=0;l<a;l++)
              for(n=0;n<a;n++){
                gecici_toplam=gecici_toplam+filter[l][n];
              }
            //////////////////////////////////////
            /*filtre pixel deƒüerlerinin ortalamasƒ± alƒ±narak ilgili pixel deƒüerinin g√ºncellenmesi */
          temp.setPix(i,j,(int)(gecici_toplam/(a*a)));
          gecici_toplam=0; // bir sonraki i≈ülemler i√ßin bu deƒüer sƒ±fƒ±rlanmalƒ±dƒ±r.
        }

   }

 return temp;
}
/*
_Median_Filter fonksiyonu: Bir √∂nceki fonksiyondan tek farkƒ± filtrede bulunan deƒüerlerinin ortalamsƒ±nƒ± alarak deƒüilde ortanca deƒüerini alarak
pixel deƒüerini g√ºnceller.
*/


Image Image:: _Median_Filter(int a ) {
    ////////////////////////////////////////////////////////////   (//) bu √ßizgiler arasƒ±nda kalan i≈ülemlerin a√ßƒ±klamalarƒ± bir √∂nceki fonksiyondayapƒ±lmƒ±≈ütƒ±r. Aynƒ± i≈ülemler olduƒüu i√ßin yeniden yorum eklenmemi≈ütir.
    Image temp(getRow(),getCol()) ; // yeni g√∂r√ºnt√º i√ßin

    int filter [a][a]; // filtre girilen a deƒüerine g√∂re olu≈üturuldu
    int i,j ; // g√∂r√ºnt√º d√∂necek
    int x,y;  // filtre i√ßin
    int k,m;
    int l,n;
    int gecici_array[a*a];
    int gecici_array_sayac=0;
    int gecici_deger;
    k= (-1)*((a-1)/2);
    m=(-1)*((a-1)/2);

    for(i=0; i<getRow(); i++)
    {
        for(j=0; j<getCol(); j++)
        {
            for(x=0; x<a; x++)
            {
                for(y=0; y<a; y++)
                {
                    if((i+k)<0 || (i+k)>getRow() || (j+m)<0 || (j+m)> getCol())
                        filter[x][y]=0;
                    else
                        filter[x][y]=getPix(i+k,j+m);
                    m=m+1;
                }
                m=(-1)*((a-1)/2);
                k=k+1;
            }
            k= (-1)*(a-1)/2;
            m= (-1)*(a-1)/2;
    ///////////////////////////////////////////////////////////
            /* ƒ∞ki boyutlu filte tek boyuta indirgenir */
            for(l=0; l<a; l++)
                for(n=0; n<a; n++)
                {
                    gecici_array[gecici_array_sayac]=filter[l][n];
                    gecici_array_sayac=gecici_array_sayac+1;
                }
            gecici_array_sayac=0; // bir sonraki i≈ülemler i√ßin sƒ±fƒ±rlanmalƒ±

            // Sƒ±ralama i≈ülemi

            for(l=0;l<(a*a);l++){
                for(n=0;n<(a*a)-1;n++) {
                    if(gecici_array[n]>gecici_array[n+1]) {
                        gecici_deger=gecici_array[n];
                        gecici_array[n]=gecici_array[n+1];
                        gecici_array[n+1]=gecici_deger;
                    }
                }
            }

            // sƒ±rlama i≈üleminden sonra ortanca deƒüerin yeni pixel koordinatƒ± ile g√ºncellenmesi.
            temp.setPix(i,j,gecici_array[((a*a)-1)/2]); // ortanca deƒüer yeni pixel deƒüeri olarak atanƒ±r.

        }

    }

    return temp;

}
////////////////////////////////////////////////// LAB-2 FONKSƒ∞YONLARI //////////////////////////////////////////////////////////////
/*
Find_Different_Pixel_Values fonksiyonu bir g√∂r√ºnt√ºde ka√ß farklƒ± pixel deƒüeri var
onu bulan fonksiyondur fakat bu lab i√ßin kullanƒ±lmamƒ±≈ütƒ±r.
*/

int Image:: Find_Different_Pixel_Values() {
    int sayac=0;
    int x = getCol()*getRow();
    int arr[x];
    int flag=0;
    int i,j,k;
    for(i=0;i<5;i++) {
         arr[i]=-1;
    }

   for(i=0;i<getRow();i++) {
        for(j=0;j<getCol();j++) {
            for(k=0;k<5;k++) {
                if(getPix(i,j)==arr[k]) {
                    flag=1;
                }
            }
            if(flag!=1) {
                arr[sayac]=getPix(i,j);
                sayac++;
            }
            flag=0;

	}
}

return sayac ;
}
/*
√ñncelikle h_r pdf ve cdf dizileri olu≈üturulmu≈ütur. Fonksiyon i√ßerisinde tam sayƒ± olmayan deƒüerler ile
√ßalƒ±≈üƒ±lacaƒüƒ± i√ßin her dizi float olarak olu≈üturulmu≈ütur.
h_r  => her pixel deƒüerinden ka√ß tane olduƒüu bilgisini tutar
pdf => her pixel deƒüerinin pdf deƒüerini tutar √∂rneƒüin pdf[0] demek 0 pixel deƒüerinin pdf'i demek
cdf => her pixel deƒüerinin cdf deƒüerini tutar √∂rneƒüin cdf[0] demek 0 pixel deƒüerinin cdf'i demek
fonksiyonda diziler doldurulduktan sonra g√∂r√ºnt√ºn√ºn pixel deƒüerleri g√ºncelleme i≈ülemi yapƒ±lmƒ±≈ütƒ±r.
cdf deƒüerleri math k√ºt√ºphanesindeki round fonksiyonu kullanƒ±larak yuvarlanmƒ±≈ütƒ±r.
*/
Image Image:: HistogramEqualization() {

    uint64_t i,j,k; // D√∂ng√º deƒüi≈ükenleri

    Image temp (getRow(),getCol()); // Fonlsiyonun d√∂neceƒüi obje olu≈üturuldu

    float h_r[256]; // her bir pixel deƒüerinden ka√ß tane olduƒüu bilgisi saklanacak
    float pdf[256];  // her bir pixel deƒüerinin pdf deƒüeri saklanacak
    float cdf[256];   // her bir pixel deƒüerinin cdf bilgisi saklanacak

    for(i=0;i<256;i++) {  // h_r dizisi i√ßin ilk deƒüer atamasƒ± yapƒ±lƒ±yor
        h_r[i]=0;
    }
   /* her bir pixel deƒüerinden ka√ß adet olduƒüu hesaplanƒ±r  */
  // h(0) =5 demek 0 dan 5 adet var demek.
    for(i=0;i<getRow();i++) {
        for(j=0;j<getCol();j++) {
            for(k=0;k<256;k++) {
                if(getPix(i,j)==k) {
                    h_r[k]=h_r[k]+1;
                    break;
                }
            }
        }
    }

    /* Her bir pixel deƒüerinin pdf deƒüeri hesaplanƒ±r */

    float x =getCol()*getRow();

    for(i=0;i<256;i++) {
        pdf[i]= (float)(h_r[i]/x);
    }
    /* Her bir pixel deƒüerinin cdf deƒüeri hesaplanƒ±r ve 256 adet pixel 8 bit ile temsil edildiƒüi i√ßin 255 ile √ßarpƒ±lƒ±r*/
     double gecici_toplam=0;
     for(i=0;i<256;i++) {
        cdf[i]=gecici_toplam+pdf[i];
        gecici_toplam=gecici_toplam+pdf[i];
        cdf[i]=255*cdf[i];
     }
     for(i=0;i<getRow();i++) {
        for(int j=0;j<getCol();j++) {
            for(k=0;k<256;k++){
                if(k==getPix(i,j)) {
                    temp.setPix(i,j,round(cdf[k]));// cdf deƒüerleri tam sayƒ± olmak zorunda olmadƒ±ƒüƒ± i√ßin pixel deƒüerleri g√ºncellemesi sƒ±rasƒ±nda yuvarlama i≈ülemi yapƒ±lƒ±r
                    break;
                }
            }
        }
     }
return temp;

}
/*
SpatialFilters fonksiyonu g√∂r√ºnt√ºy√º keskinle≈ütirilmesi i√ßin olu≈üturulmu≈ütur.
LAB'ƒ±n 2. sorusunda kullanƒ±lmƒ±≈ütƒ±r.
Ortlama filtresinde olduƒüu gibi filtre elemanlarƒ± her pixel deƒüeri i√ßin doldurulmu≈ütur
daha sonra ise laplacian filtresi i√ßin uygun katsayƒ±lar ile √ßarpƒ±larak toplanmƒ±≈ütƒ±r. yeni pixel deƒüerleri bulunmu≈ütur.

*/
Image Image:: SpatialFilters(int a,int b) {

   Image temp(getRow(),getCol()) ; // yeni g√∂r√ºnt√º i√ßin obje olu≈üturuldu

   int filter [a][a]; // filtre girilen a deƒüerine g√∂re olu≈üturuldu
   int i,j ; // g√∂r√ºnt√º d√∂necek
   int x,y;  // filtre i√ßin
   int k,m;
   int l,n;
   int gecici_toplam=0; // filtrede bulunan pixel deƒüerlerinin toplanmasƒ± i√ßin.
    /*k ve m deƒüerleri filtre arrayinin deƒüerlerinin doldurulmasƒ± i√ßin kullanƒ±lmƒ±≈ütƒ±r. */
   k= (-1)*((a-1)/2);
   m=(-1)*((a-1)/2);
    /* pixel(i,j) deƒüeri filtrenin ortasƒ±na yerle≈ütirmi≈ütir. 5x5 lik bir filtrede √∂rneƒüin 2,2 pixel koordinatƒ± oluyor
        filtrenin geri kalan koordinatlarƒ±nƒ± doldurabilmek i√ßin iki adet for d√∂ng√ºs√º daha yapƒ±lmƒ±≈ütƒ±r. k ve m deƒüerlerinde g√ºncellemeler
        yapƒ±larak bu i≈ülem saƒülanmƒ±≈ütƒ±r.Doldurulan filtre koordinatlarƒ±ndaki deƒüerler daha sonra kendilerine ait katsayƒ±lar ile √ßarpƒ±lƒ±p birbirleri
        toplanarak yeni pixel deƒüeri bulunur.
    */

   for(i=0;i<getRow();i++){
        for(j=0;j<getCol();j++){
            for(x=0;x<a;x++){
                for(y=0;y<a;y++){
                    if((i+k)<0 || (i+k)>getRow() || (j+m)<0 || (j+m)> getCol()) // k√∂≈üe veya filtrenin boyutlarƒ±na g√∂re ,filtre g√∂r√ºnt√ºn√ºn dƒ±≈üƒ±na ta≈üabilir. B√∂yle durumlarda filtre koordinatƒ±na 0 deƒüeri yazƒ±lmƒ±≈ütƒ±r.
                        filter[x][y]=0;
                    else // herhangi bir ta≈üma yoksa ilgili koordinatta g√∂r√ºnt√ºn√ºn pixel deƒüeri mevcutsa else e girer.
                        filter[x][y]=getPix(i+k,j+m);
                    m=m+1;
                }
                m=(-1)*((a-1)/2);
                k=k+1;
            }
          k= (-1)*(a-1)/2;
          m= (-1)*(a-1)/2;
          /*Filtre pixel deƒüerlerinin toplanmasƒ± */
             if(b==1) //fig3.37a mask
                gecici_toplam=filter[0][0]*0+filter[0][1]*(1)+filter[0][2]*0+filter[1][0]*(1)+filter[1][1]*(-4)+filter[1][2]*(1)+filter[2][0]*0+filter[2][1]*(1)+filter[2][2]*0;
            else if (b==2) // fig3.37b mask i√ßin
                 gecici_toplam=filter[0][0]*1+filter[0][1]*(1)+filter[0][2]*1+filter[1][0]*(1)+filter[1][1]*(-8)+filter[1][2]*(1)+filter[2][0]*1+filter[2][1]*(1)+filter[2][2]*1;
            else if(b==3)// fig3.37c mask i√ßin
                    gecici_toplam=filter[0][0]*0+filter[0][1]*(-1)+filter[0][2]*0+filter[1][0]*(-1)+filter[1][1]*(4)+filter[1][2]*(-1)+filter[2][0]*0+filter[2][1]*(-1)+filter[2][2]*0;
            else if(b==4) // fig3.37d mask i√ßin
                    gecici_toplam=filter[0][0]*(-1)+filter[0][1]*(-1)+filter[0][2]*(-1)+filter[1][0]*(-1)+filter[1][1]*(8)+filter[1][2]*(-1)+filter[2][0]*(-1)+filter[2][1]*(-1)+filter[2][2]*(-1);
            else   // Derste bahsedilen g √ßƒ±kƒ±≈ü fonksiyonu
                   gecici_toplam=filter[0][0]*0+filter[0][1]*(-1)+filter[0][2]*0+filter[1][0]*(-1)+filter[1][1]*(5)+filter[1][2]*(-1)+filter[2][0]*0+filter[2][1]*(-1)+filter[2][2]*0;
            //////////////////////////////////////
            /*filtre pixel deƒüerlerinin ortalamasƒ± alƒ±narak ilgili pixel deƒüerinin g√ºncellenmesi */
          temp.setPix(i,j,gecici_toplam);
          gecici_toplam=0; // bir sonraki i≈ülemler i√ßin bu deƒüer sƒ±fƒ±rlanmalƒ±dƒ±r.


        }

   }

 return temp;







}
/*
GaussianFilters fonksiyonu  bir gaussian filtresi uygulamak i√ßin tasarlanmƒ±≈ütƒ±r.Filtre elemanlarƒ±
daha √∂nceki filtrelerde yapƒ±ldƒ±ƒüƒ± gibi belrilenip daha sonra gaussian filtresinin katsayƒ±larƒ± ile √ßarpƒ±larak filtrenin
her bir elemanƒ± toplanmƒ±≈ütƒ±r. yeni pixel deƒüeri bu ≈üekilde belirlenmi≈ütir.


*/
Image Image:: GaussianFilters(int a) {
    /* Gaussian Filtresinin katsayƒ±larƒ±nƒ± bulmak i√ßin kullanƒ±lan algoritma Geeks for Geeks sitesinden faydalanƒ±larak olu≈üturulmu≈ütur. */
    // Gaussian Filtresinin standart sapmasƒ±nƒ±n belirlenmesi
    double sigma = 3.0;
    double r, s = 2.0 * sigma * sigma; // filtre katsayƒ±larƒ± i√ßin gereken form√ºl i√ßin kullanƒ±lacak deƒüi≈ükenler
    int x,y;  // filtrenin deƒüerlerine eri≈ümek i√ßin kullanƒ±lmƒ±≈ütƒ±r
    double coef[5][5]; // gaussian filtresinin katsayƒ±larƒ± bu array de toplanacak.

    double sum = 0.0;



    // Gauss Fƒ∞ltresinin katsayƒ±larƒ± olu≈üturulacaktƒ±r.
    for (int x = -2; x <= 2; x++) {
        for (int y = -2; y <= 2; y++) {
            r = sqrt(x * x + y * y);
            coef[x + 2][y + 2] = (exp(-(r * r) / s)) / (3.14159* s); // Gaussian filtresi katsayƒ±larƒ±nƒ± √ºretmek i√ßin kullanƒ±lan form√ºl.
            sum =sum+ coef[x + 2][y + 2];
        }
    }

    // Olu≈üturulan katsayƒ±lar normalize edilmi≈ütir.
    for (int i = 0; i < 5; ++i)
        for (int j = 0; j < 5; ++j)
            coef[i][j] =coef[i][j]/sum;

    ///////////////////////////////////////////////////////////////
    /*Filtrenin i√ß deƒüerlerinin toplanmaso  */

    Image temp(getRow(),getCol()) ; // yeni g√∂r√ºnt√º i√ßin obje olu≈üturuldu


   int i,j ; // g√∂r√ºnt√º d√∂necek
   int k,m;
   int l,n;
   double gecici_toplam=0; // filtrede bulunan pixel deƒüerlerinin toplanmasƒ± i√ßin.
   double filtre[a][a];
    /*k ve m deƒüerleri filtre arrayinin deƒüerlerinin doldurulmasƒ± i√ßin kullanƒ±lmƒ±≈ütƒ±r. */
   k= (-1)*((a-1)/2);
   m=(-1)*((a-1)/2);
    /* pixel(i,j) deƒüeri filtrenin ortasƒ±na yerle≈ütirmi≈ütir. 5x5 lik bir filtrede √∂rneƒüin 2,2 pixel koordinatƒ± oluyor
        filtrenin geri kalan koordinatlarƒ±nƒ± doldurabilmek i√ßin iki adet for d√∂ng√ºs√º daha yapƒ±lmƒ±≈ütƒ±r. k ve m deƒüerlerinde g√ºncellemeler
        yapƒ±larak bu i≈ülem saƒülanmƒ±≈ütƒ±r.Daha sonra Doldurulan filtre deƒüerleri toplanarak g√ºncel pixel deƒüeri elde edilmi≈ütir.
    */
   for(i=0;i<getRow();i++){
        for(j=0;j<getCol();j++){
            for(x=0;x<a;x++){
                for(y=0;y<a;y++){
                    if((i+k)<0 || (i+k)>getRow() || (j+m)<0 || (j+m)> getCol()) // k√∂≈üe veya filtrenin boyutlarƒ±na g√∂re ,filtre g√∂r√ºnt√ºn√ºn dƒ±≈üƒ±na ta≈üabilir. B√∂yle durumlarda filtre koordinatƒ±na 0 deƒüeri yazƒ±lmƒ±≈ütƒ±r.
                        filtre[x][y]=0;
                    else // herhangi bir ta≈üma yoksa ilgili koordinatta g√∂r√ºnt√ºn√ºn pixel deƒüeri mevcutsa else e girer.
                        filtre[x][y]=coef[x][y]*getPix(i+k,j+m);
                    m=m+1;
                }
                m=(-1)*((a-1)/2);
                k=k+1;
            }
          k= (-1)*(a-1)/2;
          m= (-1)*(a-1)/2;
          /*Filtre pixel deƒüerlerinin toplanmasƒ± */
          for(l=0;l<a;l++)
              for(n=0;n<a;n++){
                gecici_toplam=gecici_toplam+filtre[l][n];
              }
            //////////////////////////////////////
            temp.setPix(i,j,round(gecici_toplam));


          gecici_toplam=0; // bir sonraki i≈ülemler i√ßin bu deƒüer sƒ±fƒ±rlanmalƒ±dƒ±r.
        }

   }


 return temp;
}
////////////////////////////////////////////////////// LAB 3 ƒ∞√áƒ∞N FONKSƒ∞YONLAR  ////////////////////////////////
 /*
 √ñnce satƒ±r i√ßin fourier d√∂n√º≈ü√ºm√º alƒ±nacak sonra s√ºtunlar i√ßin fourier d√∂n√º≈ü√ºm√º alƒ±nacak
 en son elde edilen g√∂r√ºnt√ºn√ºn merkeze shift edilmesi ger√ßekle≈ütirilcek
 merkeze shift edilme i≈üleminden sonra da normalize edilerek obje d√∂nd√ºr√ºlecek
 */



/*
struct Complex:
Fourier d√∂n√º≈ü√ºm√º alƒ±ndƒ±ƒüƒ± zaman kompleks sayƒ±lar elde edileceƒüi i√ßin Complex adƒ±nda bir struct olu≈üturulmu≈ütur.
Bu lab i√ßin yazƒ±lan t√ºm fonksiyonlarda dinamik hafƒ±za ile bu structlardan olu≈üturulmu≈ütur. Olu≈üturulan bu hafƒ±za alanlarƒ±, Her bir pixel deƒüerinin fourier sonu√ßlarƒ±nƒ±
tutmak i√ßin kullanƒ±lmƒ±≈ütƒ±r.

*/

 typedef struct Complex {
        double real ; // pixel deƒüerinin real fourier kat sayƒ±sƒ±nƒ± tutacak
        double imag ;// pixel deƒüerinin sanal fourier kat sayƒ±sƒ±nƒ± tutacak
   }Complex;
/*
Fourier_Transform():
Bu fonksiyon verilen g√∂r√ºnt√ºn√ºn fourier d√∂n√º≈ü√ºm√º yapar. Her pixel deƒüeri i√ßin fourier d√∂n√º≈ü√ºm√º alƒ±nƒ±r ve olu≈üan kompleks sayƒ±lar
bir obje i√ßerisinde tutulur ve return edilir.
Transform i≈ülemi kitapta 298. SAYFA VERƒ∞LEN FORM√úLE G√ñRE YAPILMI≈ûTIR. ilk √º√ßl√º for f(x,v) yi elde etmek i√ßin sonra d√∂nen √º√ß for f(u,v) yi elde etmek
i√ßindir.

*/
Image Image::Fourier_Transform() {
int row = getRow();// fourier i alƒ±nacak fonksiyonun satƒ±r sayƒ±sƒ±
    int col = getCol();// fourier i alƒ±nacak fonksiyonun s√ºtun sayƒ±sƒ±
    int x,y,u,v,i,j;// d√∂ng√ºlerde kullanƒ±lacak deƒüi≈ükenler
    /* FFTShfit i≈ülemi i√ßin her pixel -1^(i+j) ile √ßarpƒ±ldƒ± */
    for(int i=0;i<getRow();i++)
        for(int j=0;j<getCol();j++)
               setPix(i,j,pow(-1,(i+j))*getPix(i,j));

    /* F(x,v) ve F(u,v) fonksiyonlarƒ± i√ßin dinsmik hafƒ±za ile yer ayrƒ±ldƒ±  */
    Complex** fourier_xv = (Complex**)malloc(row * sizeof(Complex*));
    for ( i = 0; i < row; i++)
        fourier_xv[i] = (Complex*)malloc(col * sizeof(Complex));


    Complex** fourier_uv = (Complex**)malloc(row * sizeof(Complex*));
    for ( i = 0; i < row; i++)
        fourier_uv[i] = (Complex*)malloc(col * sizeof(Complex));

     /* D√∂ng√ºler de toplama yaparken kullnƒ±lacak ara deƒüi≈ükenler  */
    double gecici_real = 0;
    double gecici_imag = 0;
     /* 1. √ú√áL√ú FOR yapƒ±sƒ± F(x,v) deƒüerlerinin bulunmasƒ± i√ßin olu≈üturulmu≈ütur  */
    for (x = 0; x < row; x++) {
        for ( v = 0; v < col; v++) {

            for ( y = 0; y < col; ++y) {
               gecici_real += getPix(x, y) * cos( 2 * pi * y * v / col);
                gecici_imag += -getPix(x, y) * sin( 2 * pi * y * v / col);
            }
            fourier_xv[x][v].real = gecici_real;// ilgili pixel de ki  F(x,v)nin real deƒüeri
            fourier_xv[x][v].imag = gecici_imag; // ilgili pixel de ki  F(x,v)nin imajiner deƒüeri
              /* Ara deƒüerlerin bir sonraki pixel deƒüerinin hesaplanmasƒ± i√ßin sƒ±fƒ±rlanmasƒ± gerekmektedir  */
            gecici_real=0;
            gecici_imag=0;
        }
    }
     gecici_real=0;
     gecici_imag=0;
     /* 2. √ú√áL√ú FOR yapƒ±sƒ± F(u,v) deƒüerlerinin bulunmasƒ± i√ßin olu≈üturulmu≈ütur  */
    for ( u = 0; u < row; u++) {
        for ( v = 0; v < col; v++) {

            for (x = 0; x < row; x++) {
                gecici_real += fourier_xv[x][v].real * cos( 2 * pi * x * u / row) + fourier_xv[x][v].imag * sin( 2 * pi * x * u / row);
                gecici_imag += -fourier_xv[x][v].real * sin( 2 * pi * x * u / row) + fourier_xv[x][v].imag * cos( 2 * pi * x * u / row);
            }
            fourier_uv[u][v].real = gecici_real;// ilgili pixel de ki  F(u,v)nin real deƒüeri
            fourier_uv[u][v].imag = gecici_imag;// ilgili pixel de ki  F(u,v)nin imajiner deƒüeri
             /* Ara deƒüerlerin bir sonraki pixel deƒüerinin hesaplanmasƒ± i√ßin sƒ±fƒ±rlanmasƒ± gerekmektedir  */
            gecici_real=0;
            gecici_imag=0;
        }
    }

   /* F(x,v) i√ßin ayrƒ±lan alan bo≈üaltƒ±ldƒ±  */
    for ( i = 0; i < row; i++)
        free(fourier_xv[i]);

    free(fourier_xv);

    Image temp;
    temp.createImage(row, 2 * col);// d√∂nd√ºr√ºlecek nesne olu≈üturuldu
// d√∂nd√ºr√ºlecek nesnenin s√ºtun sayƒ±sƒ± giri≈ü g√∂r√ºnt√ºs√ºn√ºn s√ºtun sayƒ±sƒ±nƒ±n iki katƒ± kadardƒ±r. Bunun nedeni imajiner katsayƒ±larƒ± da ters d√∂n√º≈ü√ºm i√ßin saklamaktƒ±r. Daha detaylƒ± a√ßƒ±klama rapora eklenmi≈ütir
    for ( i = 0; i < row; i++)// real fourier kat sayƒ±larƒ± objeye eklendi
        for ( j = 0; j < col; j++)
            temp(i, j) = fourier_uv[i][j].real;

    int k;
    for ( i = 0; i < row; i++)
        for ( j = col, k = 0; j < 2 * col; j++, k++)// sanal fourier kat sayƒ±larƒ± objeye eklendi
            temp(i, j) = fourier_uv[i][k].imag;

    // Dinamik hafiza ile ayrƒ±lan alanlarƒ±n bo≈üaltƒ±lmasƒ±
     /* F(u,v) i√ßin ayrƒ±lan alan bo≈üaltƒ±ldƒ±  */
    for ( i = 0; i < row; ++i)
        free(fourier_uv[i]);

    free(fourier_uv);

    return temp;
 }
/*
Print_Fourier():
Fourier D√∂n√º≈ü√ºm√º yapƒ±lƒ±rken s√ºtun sayƒ±sƒ± iki katƒ±na √ßƒ±karƒ±lmƒ±≈ütƒ±r. Bunun sebebi ise sanal katsayƒ±larƒ±n da saklanmasƒ±nƒ± saƒülamaktƒ±r.
√á√ºnk√º sanal sayƒ±lar ters fourier alƒ±rken kullanƒ±lacaktƒ±r. S√ºtun sayƒ±sƒ± iki katƒ±na √ßƒ±karƒ±ldƒ±ƒüƒ± i√ßin g√∂r√ºnt√ºn√ºn bastƒ±rma i≈ülemi i√ßin ayrƒ± bir fonksiyon yazƒ±lmƒ±≈ütƒ±r.
Bu fonksiyon Fourier Transformu sonucu d√∂nen objenin col/2 s√ºtununa kadar ki real kat sayƒ±larƒ± ile (col/2-col) s√ºtunlarƒ± arasƒ±ndaki imajiner kat sayƒ±larƒ±nƒ±n ayrƒ± ayrƒ±
karesini alƒ±p sonra kare k√∂klerini alarak fourier transformu alƒ±nan g√∂r√ºnt√ºn√ºn bastƒ±rƒ±lmasƒ±nƒ± saƒülar. Kurulan algoritma rapora eklenen g√∂rsel de daha iyi anlatƒ±lmƒ±≈ütƒ±r.
*/
Image Image:: Print_Fourier() {  // m  2n g√∂r√ºnt√º gelecek
 Image temp;
    int row = getRow();
    int col =getCol();// orijinal g√∂r√ºnt√ºn√ºn s√ºtun sayƒ±sƒ±nƒ±n iki katƒ± s√ºtun sayƒ±sƒ±na sahip deƒüer gelecek
    temp.createImage(row, col / 2);
    int p;
    // d√∂necek obje col/2 s√ºtunlu, fakat fourier alƒ±nmƒ±≈ü olarak gelen g√∂r√ºnt√º col s√ºtunlu bu y√ºzden deƒüer atamalarƒ± yapƒ±lƒ±rken ekstra bir p deƒüi≈ükenine ihtiyac duyuldu.
    for (int i = 0; i < row; i++)
        for (int j = 0, p = 0; p < col / 2, j < col; j++, p++)
            temp.setPix(i, p,sqrt(getPix(i, j) * getPix(i, j) + getPix(i, j + col / 2) *getPix(i, j + col / 2))); // karek√∂k(real*real + sanal*sanal)

    return temp;

}
/*
 Fourier_Adim0():  Bu fonksiyon  Adƒ±m0'a √∂zel olarak yazƒ±lmƒ±≈ütƒ±r. Knedi i√ßerisinde fourier ve ters fourier d√∂n√º≈ü√ºmlerini yapmaktadƒ±r. Bu adƒ±mda dinamik hafƒ±za ve struct
 yapƒ±larƒ± kullanƒ±lmadƒ±ƒüƒ± ve ekrana basma i≈ülemleri yapƒ±ldƒ±ƒüƒ± i√ßin ayrƒ± bir fonksiyon yapƒ±lmƒ±≈ütƒ±r. Fakat fourier ve ters fourier d√∂n√º≈ü√ºmlerinde kurulan 3 l√º for yapƒ±larƒ± diƒüer
 fonksiyonlar ile aynƒ±dƒ±r. For yspƒ±larƒ± aynƒ± olduƒüu i√ßin tekrar yorum yapƒ±lmamƒ±≈ütƒ±r.

*/

void  Image::  Fourier_Adim0() {
    int row =getRow();// fourier i alƒ±nacak fonksiyonun satƒ±r sayƒ±sƒ±
    int col=getCol();// fourier i alƒ±nacak fonksiyonun s√ºtun sayƒ±sƒ±

    double fast_imag[row][col]={0}; // fourier sonucu sanal kisim icin
	double fast_real[row][col]={0}; // fourier sonucu real kisim icin

	double fast_imag_temp[row][col]={0};// f(x,v) fonksiyonu i√ßin
	double fast_real_temp[row][col]={0};// f(x,v) fonksiyonu i√ßin
    // 1. √ú√áL√ú FOR YAPISI
	int u,v,x,y,i,j;
	double gecici_toplam_real=0;
	double gecici_toplam_imag=0;

	for(y=0;y<row;y++) {
		for(u=0;u<col;u++) {
			for(x=0;x<col;x++) {
				gecici_toplam_real=gecici_toplam_real+getPix(x,y)*cos(2*pi*u*x/col); // real toplama
				gecici_toplam_imag =gecici_toplam_imag +(getPix(x,y)*(-1)*sin(2*pi*u*x/col)); // sanal toplama
			}
				fast_real_temp[y][u] =gecici_toplam_real;
				fast_imag_temp[y][u]=gecici_toplam_imag ;
				gecici_toplam_imag=0;
				gecici_toplam_real=0;
		}
	}


	gecici_toplam_imag=0;
	gecici_toplam_real=0;
    // 2. √ú√áL√ú FOR YAPISI
	for(u=0;u<row;u++){
		for(v=0;v<col;v++) {
			for(y=0;y<row;y++) {
				// gecici_toplam_imag=  gecici_toplam_imag + (fast_imag_temp[x][v]*-sin(2*3.14*u*x/3))  ; // sanal toplama
			  //	gecici_toplam_real=  gecici_toplam_real+fast_real_temp[x][v]*cos(2*3.14*u*x/3); // real toplama
			  	gecici_toplam_real=	gecici_toplam_real+ fast_real_temp[y][u]*cos(2*pi*v*y/row)-sin(2*pi*v*y/row)*fast_imag_temp[y][u];
			  	gecici_toplam_imag= gecici_toplam_imag- fast_real_temp[y][u]*sin(2*pi*v*y/row)-cos(2*pi*v*y/row)*fast_imag_temp[y][u];

			}
			fast_real[u][v] =	gecici_toplam_real ;
			fast_imag[u][v]=	gecici_toplam_imag;
			gecici_toplam_imag=0;
			gecici_toplam_real=0;

		}
	}

		gecici_toplam_imag=0;
		gecici_toplam_real=0;
/* Elde edilen fourier d√∂n√º≈ü√ºm√º sonu√ßlarƒ±nƒ±n ekranda g√∂sterilmesi  */
    cout<<"GERCEK GORUNTU DEGERLERI"<<endl;
    for(i=0;i<row;i++) {
        for(j=0;j<col;j++) {
                cout<<getPix(i,j)<<" ";
        }
       cout<<endl;
    }

    cout<<"FOURIER SONUCLARI"<<endl;
    cout<<endl;
    cout<<"REAL KISIM SONUCLARI:"<<endl;
	for(i=0;i<row;i++){
		for(j=0;j<col;j++){
			cout<<  (fast_real[i][j] )<<" ";
		}
		cout<<endl;

	}

	cout<<"SANAL KISIM SONUCLARI:"<<endl;
	for(i=0;i<row;i++){
		for(j=0;j<col;j++){
			cout<<  (fast_imag[i][j] )<<" ";
		}
		cout<<endl;

	}
	/////////////////// INVERSE FOURIER TRANSFORM //////////////////777
	 /* Ters fourier de elde edilecek kat sayƒ±larƒ± tutmak i√ßin olu≈üturulan array ler.  */
   double inverse_temp_real[row][col] = {0};
	double inverse_temp_imag[row][col]={0};


	double inverse_real[row][col]={0};
	double inverse_imag[row][col]={0};

    gecici_toplam_imag=0;
    gecici_toplam_real=0;

     // 1. √ú√áL√ú FOR YAPISI
		for ( v = 0; v < row; v++) {// f(u,v) fourier d√∂n√º≈ü√ºm√º sonucunda elde edilmi≈ütir.
        for ( x = 0; x < col; x++) {
            double real = 0;
            double imag = 0;
            for ( u = 0; u < row ; u++) {
                gecici_toplam_real += fast_real[u][v] * cos(2 * pi * x * u / (row)) + fast_imag[u][v] * (-sin(2 * pi * x * u / (row)));
                gecici_toplam_imag += fast_real[u][v] * sin(2 * pi * x * u / (row)) + fast_imag[u][v] * cos(2 * pi * x * u / (row));
            }
           inverse_temp_real[x][v] = gecici_toplam_real;
           inverse_temp_imag[x][v] =  gecici_toplam_imag;
           gecici_toplam_imag=0;
           gecici_toplam_real=0;
        }
    }
         // 2. √ú√áL√ú FOR YAPISI
    // bu √º√ßl√º for sonunda, daha √∂nce bulunan f(x,v) fonksiyonu sayesinde orijinal deƒüerler olan f(x,y) deƒüerleri elde edilmi≈ütir.
    for (int x = 0; x < row; x++) {
        for (int y = 0; y < col ; y++) {
           for (int v = 0; v < col; v++) {
                gecici_toplam_real +=  inverse_temp_real[x][v] * cos(2 * pi * v * y / col) +  inverse_temp_imag[x][v] * (-sin(2 * pi * v * y / col));
                gecici_toplam_imag +=  inverse_temp_real[x][v] * sin(2 * pi * v * y / col) +  inverse_temp_imag[x][v] * cos(2 * pi * v * y / col);
            }
            inverse_real[x][y] = gecici_toplam_real;
            inverse_imag[x][y] = gecici_toplam_imag;
             gecici_toplam_imag=0;
            gecici_toplam_real=0;
        }
    }

    int k,l ;
    /* her satƒ±r i√ßin elde edilen sonu√ßlarƒ±n yerleri belirlenemeyen sebebpten dolayƒ± yanlƒ±≈ü gelmektedir. Pixel deƒüerlerinin yerleri 2. 3. √º√ßl√º for da karƒ±≈ütƒ±ƒüƒ±
     tahmin edilmektedir. ƒ∞lk √º√ßl√º for sonunda gelmesi gereken ara deƒüerler doƒüru bir ≈üekilde elde edilmektedir. satƒ±rlarƒ±n d√ºzg√ºn sƒ±ralanmasƒ± i√ßin ekstra kod eklenmesi gerekmektedir.Bu kod sayesinde
    fourier sonu√ßlarƒ± olmasƒ± gereken lokasyona yerle≈ümektedir.
    */

  for ( i = 0; i < row; i++)
  {

    for ( j = 0; j < col; j++)
    {

      for ( k = 0; k < row; k++)
      {
      	for( l=0;l<col;l++) {
      		 if (inverse_real[i][j] < inverse_real[k][l])
        {

          swap(inverse_real[i][j], inverse_real[k][l]);
        }
		  }

      }
    }
  }

cout<<"TERS FOURIER SONUCLARI"<<endl;
cout<<endl;

cout<<"REAL KISIM SONUCLARI:"<<endl;
	for(i=0;i<row;i++){
		for(j=0;j<col;j++){
			cout<<round (inverse_real[i][j]/(double)(col*row))<<" ";
		}
		cout<<endl;

	}

	cout<<"SANAL KISIM SONUCLARI:"<<endl;
	for(i=0;i<row;i++){
		for(j=0;j<col;j++){
			cout<< round (inverse_imag[i][j]/(double)(col*row))<<" ";
		}
		cout<<endl;

	}


}
// TERS FOURƒ∞ER ƒ∞√áƒ∞N YAZILAN BU FONKSƒ∞YON √áALI≈ûMAMAKTADIR
Image Image:: Inverse_Fourier() {
    int row =getRow(); // m
    int col=getCol();  //n

    int u,v,x,y,i,j;
    Image temp (row,col/2);

    /* F(x,v) ve F(u,v) fonksiyonlarƒ± i√ßin dinsmik hafƒ±za ile yer ayrƒ±ldƒ±  */
    Complex** fourier_xv = (Complex**)malloc(row * sizeof(Complex*));
    for ( i = 0; i < row; i++)
        fourier_xv[i] = (Complex*)malloc((col/2) * sizeof(Complex));


    Complex** fourier_xy = (Complex**)malloc(row * sizeof(Complex*));
    for ( i = 0; i < row; i++)
        fourier_xy[i] = (Complex*)malloc( (col/2) * sizeof(Complex));


    Complex** fourier_uv = (Complex**)malloc(row * sizeof(Complex*));
    for ( i = 0; i < row; ++i)
        fourier_uv[i] = (Complex*)malloc((col/2) * sizeof(Complex));


    double real_toplam=0;
    double imag_toplam=0;


    for(i=0;i<row;i++) {
        for(j=0;j<col/2;j++) {
            fourier_uv[i][j].real=getPix(i,j); // uv nin real kƒ±sƒ±mlarƒ± alƒ±ndƒ±
        }
    }
    for(i=0;i<row;i++) {
        for(u=0,j=col/2; u<col/2,j<col;u++ ,j++) {
            fourier_uv[i][u].imag=getPix(i,j); // uv nin imajiner  kƒ±sƒ±mlarƒ± alƒ±ndƒ±
        }
    }


   for ( x = 0; x < row; x++) {
        for ( v = 0; v < col/2; v++) {
            for ( u = 0; u < row ; u++) {
                double theta = 2 * pi * x * u / (row);
                real_toplam += fourier_uv[u][v].real * cos(theta) + fourier_uv[u][v].imag * (-sin(theta));
               imag_toplam += fourier_uv[u][v].real * sin(theta) + fourier_uv[u][v].imag * cos(theta);
            }
           fourier_xv[x][v].real = real_toplam;
            fourier_xv[x][v].imag = imag_toplam;
            real_toplam=0;
            imag_toplam=0;
        }
    }


    for ( x = 0; x < row; x++) {
        for ( y = 0; y < col/2 ; y++) {

           for ( v = 0; v < col/2; v++) {
               double theta = 2 * pi * v * y / col;
                real_toplam +=  fourier_xv[x][v].real * cos(theta) +  fourier_xv[x][v].imag * (-sin(theta));
                imag_toplam +=  fourier_xv[x][v].real * sin(theta) +  fourier_xv[x][v].imag * cos(theta);
            }
            fourier_xy[x][y].real = real_toplam;
            fourier_xy[x][y].imag = imag_toplam;
            real_toplam=0;
            imag_toplam=0;
        }
    }





    for(int i=0;i<row;i++)
        for(int j=0;j<col/2;j++)
               temp.setPix(i,j,pow(-1,(i+j))*temp.getPix(i,j));

      for ( i = 0; i < row; ++i) {
        free(fourier_uv[i]);
        free(fourier_xv[i]);
        free(fourier_xy[i]);
      }
    free(fourier_uv);
    free(fourier_xv);
    free(fourier_xy);


return temp ;
}
// Bu fonksiyon adƒ±m0 i√ßin tasarlanmƒ±≈ütƒ±r fakat kullanƒ±lmamƒ±≈ütƒ±r.
Image Image:: Create_Image(int row , int col ) {

    Image temp (row,col);
    int sayac=1;
    for(int i =0;i<row;i++) {
        for(int j=0;j<col;j++) {
            temp.setPix(i,j,sayac);
            sayac++;
        }
    }

    return temp ;
}

// Ters fourier almak i√ßin iki adet fonksiyon denemesi yapƒ±lmƒ±≈ütƒ±r. Fonksiyon adƒ±nda 2 olmasƒ±nƒ±n sebebi budur.
Image Image:: InverseFourier2 () {
    int row = getRow();// ters fourier i alƒ±nacak g√∂r√ºnt√ºn√ºn satƒ±r sayƒ±sƒ±
    int col  =getCol();// ters fourier i alƒ±nacak g√∂r√ºnt√ºn√ºn satƒ±r sayƒ±sƒ±
    int i,j,u,v,x,y;
 /* f(u,v),f(x,v) ve f(x,y) deƒüerleri bir Comples struct array i halinde saklanacaktƒ±r. Bu y√ºzden dinamik hafƒ±za ile yer ayrƒ±lma i≈ülemi yapƒ±lmƒ±≈ütƒ±r  */
    Complex** fourier_uv = (Complex**)malloc(row * sizeof(Complex*));
    for ( i = 0; i < row; ++i)
        fourier_uv[i] = (Complex*)malloc((col/2) * sizeof(Complex));


    Complex** fourier_xv = (Complex**)malloc(row * sizeof(Complex*));


    for ( i = 0; i < row; i++)
        fourier_xv[i] = (Complex*)malloc((col/2) * sizeof(Complex));


    Complex** fourier_xy = (Complex**)malloc(row * sizeof(Complex*));
    for ( i = 0; i < row; i++)
        fourier_xy[i] = (Complex*)malloc((col/2) * sizeof(Complex));

    /////////////////////////////////////////////////////////////////////
     /* Gelen g√∂r√ºnt√ºn√ºn real ve sanal kat sayƒ±larƒ± (Fourier d√∂n√º≈ü√ºm√º yapƒ±lmƒ±≈ü sonu√ßlar), fourier(u,v) dizisi i√ßerisine yerle≈ütirilmi≈ütir.   */

    for ( i = 0; i < row; i++)
        for ( j = 0; j < col / 2; j++)
            fourier_uv[i][j].real = getPix(i, j);

    int k ;
    for ( i = 0; i < row; ++i)
        for ( k=0, j = col/2; k<col/2 , j < col; k++ , j++) {
            fourier_uv[i][k].imag = getPix(i, j);
        }

/* D√∂ng√ºler de toplama yaparken kullnƒ±lacak ara deƒüi≈ükenler  */
    double real_toplam = 0;
    double imag_toplam = 0;
    // Sayfa 298 de verilen formul√ºn ters fourier i√ßin geri i≈ületilmesi , bu for lar i√ßin referans alƒ±nan sayfa 299 da verilmi≈ütir.
    // ƒ∞LK √ú√áL√ú FOR SONUNDA ELƒ∞Mƒ∞ZDE BULUNAN F(U,V) DEƒûERLERƒ∞NDEN F(X,V) DEƒûERLERƒ∞ ELDE EDƒ∞LMƒ∞≈ûTƒ∞R.
    for ( v = 0; v < col/2; v++) {
        for ( x = 0; x < row; x++) {

            for ( y = 0; y < col / 2; y++) {

                real_toplam +=  fourier_uv[x][y].real * cos(2 * pi * y * v / (col/2)) +  (fourier_uv[x][y].imag) * (-sin(2 * pi * y * v / (col/2)));
                imag_toplam+=  fourier_uv[x][y].real * sin(2 * pi * y * v / (col/2)) +  (fourier_uv[x][y].imag) * cos(2 * pi * y * v / (col/2));
            }
            fourier_xv[x][v].real = real_toplam;
            fourier_xv[x][v].imag = imag_toplam;
            real_toplam=0;
            imag_toplam=0;
        }
    }
   real_toplam=0;
    imag_toplam=0;
    // Dinamik ayrƒ±lan hafƒ±zanƒ±n bo≈üaltƒ±lmasƒ±, Bu i≈ülem ayrƒ±lan hafƒ±za ile i≈ülem bittikten sonra hemen bo≈üaltƒ±lmasƒ± i√ßin yapƒ±lmƒ±≈ütƒ±r.(Memory leak olmamasƒ± i√ßin)
    for (  i = 0; i < row; i++)
        free(fourier_uv[i]);

    free(fourier_uv);
 // ƒ∞Kƒ∞NCƒ∞  √ú√áL√ú FOR SONUNDA ELƒ∞Mƒ∞ZDE BULUNAN F(X,V) DEƒûERLERƒ∞NDEN F(X,Y) DEƒûERLERƒ∞ (YANƒ∞ ORƒ∞Jƒ∞NAL G√ñR√úNT√ú) ELDE EDƒ∞LMƒ∞≈ûTƒ∞R.
    for ( u = 0; u < row; u++) {
        for ( v = 0; v < col / 2; v++) {

            for (int x = 0; x < row; x++) {

                real_toplam += fourier_xv[x][v].real * cos(2 * pi * x * u / row) + (fourier_xv[x][v].imag) * (-sin(2 * pi * x * u / row));
                 imag_toplam += fourier_xv[x][v].real * sin(2 * pi * x * u / row) + (fourier_xv[x][v].imag) * cos(2 * pi * x * u / row);
            }
            fourier_xy[u][v].real = real_toplam;
            fourier_xy[u][v].imag = imag_toplam;
             real_toplam=0;
            imag_toplam=0;
        }
    }
 /*Dinamik hafƒ±za ile ayrƒ±lan alanlarƒ±n bo≈üaltƒ±lmasƒ±  */
    for ( i = 0; i < row; i++)
        free(fourier_xv[i]);

    free(fourier_xv);
/////////////////////////////////////////////////////////////////
    /* Fourier alƒ±nmƒ±≈ü g√∂r√ºnt√ºn√ºn s√ºtun sayƒ±sƒ± orijinal g√∂r√ºnt√ºn√ºn s√ºtun sayƒ±sƒ±nƒ±n iki katƒ±dƒ±r. Bunun sebebi sanal kat sayƒ±larƒ± da tutumaktƒ±r.
       yani bu fonksiyonda ki col deƒüeri, (orijinal g√∂r√ºnt√ºn√ºn s√ºtun sayƒ±sƒ± n ise)   2*n kadardƒ±r. Sonu√ßta ters fourier alƒ±ndƒ±ƒüƒ±nda g√∂r√ºnt√ºn√ºn boyutu
       deƒüi≈ümemesi i√ßin col/2 s√ºtun kadar yeni bir g√∂r√ºnt√º olu≈üturulmasƒ± gerekir. temp objesinin s√ºtun sayƒ±sƒ±ƒ±nƒ±n col/2 olma sebebi budur.
       */
    Image temp;
    temp.createImage(row, col / 2);
    /* √º√ßl√º for lar ile bulunan sonu√ßlarƒ±n obje de set edilmesi. Sanal kƒ±sƒ±m olmamasƒ± gereketiƒüi i√ßin sadece real kƒ±sƒ±mlar e≈ülenmi≈ütir. Formulden dolayƒ± da (1/mn) ile √ßarpma i≈ülemi ger√ßekle≈ütirilmi≈ütir. */
    for ( i = 0; i < row; i++)
        for ( j = 0; j < col / 2; j++)
            temp(i, j) = fourier_xy[i][j].real/(row*col/2);
     /* FourierD√∂n√º≈ü√ºm√º alƒ±nƒ±rken DC yi merkeze kaydƒ±rma i≈ülemi ≈üimdi en sƒ±nda yapƒ±larak otijinal g√∂r√ºnt√ºn√ºn elde edilmesi saƒülanmƒ±≈ütƒ±r. */
    for( i=0;i<row;i++)
        for( j=0;j<col/2;j++)
               temp.setPix(i,j,pow(-1,(i+j))*temp.getPix(i,j));

    for ( i = 0; i < row; ++i)
        free(fourier_xy[i]);

    free(fourier_xy);

    return temp;

}
//////////////////////////////////// LAB4 FONKSƒ∞YONLAR /////////////////////////////////////////////////////
/*
Sobel_Gradient(): Fonksiyonu g√∂r√ºnt√ºn√ºn her bir pixel'ini sobel kat sayƒ±larƒ± ile √ßarpar.
Her pixel deƒüerini 3x3 l√ºk matrisde merkeze alarak ,her pixel deƒüerini kitapta verilen
sobel kat sayƒ± matrisleri ile √ßarpar ve mutlak deƒüer alarak her iki sobel kat sayƒ±sƒ±ndan
gelen sonu√ßlarƒ± toplar.
*/
Image Image:: Sobel_Gradient() {
    Image temp(getRow(),getCol()) ; // yeni g√∂r√ºnt√º i√ßin obje olu≈üturuldu

   double filter [3][3]; // 3xe l√ºk matris olu≈üturuldu
   int i,j ; // g√∂r√ºnt√º d√∂necek
   int x,y;  // filtre i√ßin
   int k,m;
   int l,n;
   double gx=0; // kitapta verilen gx sobel kat sayƒ±sƒ±.
   double gy=0; // kitapta verilen gy sobel kat sayƒ±sƒ±.
    /*k ve m deƒüerleri filtre arrayinin deƒüerlerinin doldurulmasƒ± i√ßin kullanƒ±lmƒ±≈ütƒ±r. */
   k= (-1)*((3-1)/2);
   m=(-1)*((3-1)/2);
    /* pixel(i,j) deƒüeri filtrenin ortasƒ±na yerle≈ütirmi≈ütir. 5x5 lik bir filtrede √∂rneƒüin 2,2 pixel koordinatƒ± oluyor
        filtrenin geri kalan koordinatlarƒ±nƒ± doldurabilmek i√ßin iki adet for d√∂ng√ºs√º daha yapƒ±lmƒ±≈ütƒ±r. k ve m deƒüerlerinde g√ºncellemeler
        yapƒ±larak bu i≈ülem saƒülanmƒ±≈ütƒ±r.
    */

   for(i=0;i<getRow();i++){
        for(j=0;j<getCol();j++){
            for(x=0;x<3;x++){
                for(y=0;y<3;y++){
                    if((i+k)<0 || (i+k)>getRow() || (j+m)<0 || (j+m)> getCol()) // k√∂≈üe veya filtrenin boyutlarƒ±na g√∂re ,filtre g√∂r√ºnt√ºn√ºn dƒ±≈üƒ±na ta≈üabilir. B√∂yle durumlarda filtre koordinatƒ±na 0 deƒüeri yazƒ±lmƒ±≈ütƒ±r.
                        filter[x][y]=0;
                    else // herhangi bir ta≈üma yoksa ilgili koordinatta g√∂r√ºnt√ºn√ºn pixel deƒüeri mevcutsa else e girer.
                        filter[x][y]=getPix(i+k,j+m);
                    m=m+1;
                }
                m=(-1)*((3-1)/2);
                k=k+1;
            }
          k= (-1)*(3-1)/2;
          m= (-1)*(3-1)/2;
          /*Kitapta verilen gx gy sobel kat sayƒ±larƒ±nƒ±n uygulanmasƒ± */
             //gx
                gx=filter[0][0]*(-1)+filter[0][1]*(-2)+filter[0][2]*(-1)+filter[1][0]*(0)+filter[1][1]*(0)+filter[1][2]*(0)+filter[2][0]*1+filter[2][1]*(2)+filter[2][2]*1;
            // gy
                 gy=filter[0][0]*(-1)+filter[0][1]*(0)+filter[0][2]*1+filter[1][0]*(-2)+filter[1][1]*(0)+filter[1][2]*(2)+filter[2][0]*(-1)+filter[2][1]*(0)+filter[2][2]*1;
            // ilgili pixel i√ßin sonucun elde edilmesin de iki gx ve gy nin ayrƒ± ayrƒ± mutlak deƒüerleri alƒ±narak toplanmasƒ± gerekmektedir.
            if(gx<0)
                gx=gx*(-1);
            if(gy<0)
               gy=gy*-1;
            //////////////////////////////////////
            /*sonucun yazƒ±lmasƒ±*/
          temp.setPix(i,j,gx+gy);
          gx=0;gy=0; // bir sonraki i≈ülemler i√ßin bu deƒüer sƒ±fƒ±rlanmalƒ±dƒ±r.


        }

   }

 return temp;

}
/*
Scale(): fonksiyonu , pixel deƒüerleri a-b aralƒ±ƒüƒ±da olan g√∂r√ºnt√ºn√ºn pixel deƒüerlerini 0-255 arasƒ±na
√ßekmek i√ßin kullanƒ±lƒ±r. Bu √ñDEVDE KULLANILMAMI≈ûTIR.
*/
Image Image:: Scale() {
    double max_value=getMaximum();
    double min_value=getMinimum();
    double istenen_max=255;
    double istenen_min=0;
    double scaled_value= ((istenen_max-istenen_min)/(max_value-min_value));
    Image temp(getRow(),getCol());
    for(int i =0;i<getRow();i++)
        for(int j=0;j<getCol();j++)
                temp.setPix(i,j,getPix(i,j)*scaled_value);

   return temp;
}
/*
H_uv(): fonksiyonu fourier d√∂n√º≈ü√ºm√º alƒ±nmƒ±≈ü fonksiyona uygulanƒ±r. Bu fonksiyona gelen g√∂r√ºnt√º m satƒ±r
2n s√ºtundan olu≈üur ilk n s√ºtun reel kat sayƒ±larƒ±, 2n-n s√ºtunlarƒ± da sanal kat sayƒ±larƒ± tutar. Fonksiyon i√ßerisinde
g√∂r√ºnt√ºn√ºn hem reel hem de sanal kat sayƒ±larƒ± olu≈üturulan H(u,v) sinyali ile √ßarpƒ±lƒ±r. √á√ºnk√º reel bir sayƒ± ile (H_uv)
Konpleks bir sayƒ± (F_uv) √ßarpƒ±lmaktadƒ±r.

*/
 Image Image:: H_uv() {
    int row = getRow(); // m
    int col =getCol();// orijinal g√∂r√ºnt√ºn√ºn s√ºtun sayƒ±sƒ±nƒ±n iki katƒ± s√ºtun sayƒ±sƒ±na sahip deƒüer gelecek  // 2n
     int p,k,i,j;

     // real kƒ±sƒ±m, fourieri alƒ±nmƒ±≈ü g√∂r√ºnt√ºn√ºn real kƒ±sƒ±mlarƒ±nƒ± tutacak
    double** fourier_real = (double**)malloc(row * sizeof(double*));
    for ( i = 0; i < row; i++)
        fourier_real[i] = (double*)malloc((col/2) * sizeof(double));

    //sanal  , fourieri alƒ±nmƒ±≈ü g√∂r√ºnt√ºn√ºn sanal kƒ±sƒ±mlarƒ±nƒ± tutacak
    double** fourier_sanal = (double**)malloc(row * sizeof(double*));
    for ( i = 0; i < row; i++)
        fourier_sanal[i] = (double*)malloc((col/2) * sizeof(double));

     // h_uv sinyali i√ßin hafƒ±zada yer ayrƒ±lmasƒ±
    double** h_uv = (double**)malloc(row * sizeof(double*));
    for ( i = 0; i < row; i++)
        h_uv [i] = (double*)malloc((col/2) * sizeof(double));
    // H_uv deƒüerlerinin belirlenmesi
    for(i=0; i<row; i++)
        for(j=0; j<col/2; j++) {
            double value= (-4*pi*pi)* ((i-row/2)*(i-row/2)+(j-col/4)*(j-col/4)); // col/4 denmesinin sebebi gelen g√∂r√ºnt√ºn√ºn s√ºtun sayƒ±sƒ± olmasƒ± gerekenden 2 kat fazla bu y√ºzden b√∂lerken bir kere daha b√∂l√ºnd√º
            h_uv[i][j]=value;
        }

    // g√∂r√ºnt√ºen real kƒ±sƒ±mlarƒ± almak
    for ( i = 0; i < row; i++)
        for ( j = 0; j < col / 2; j++)
             fourier_real[i][j]= getPix(i, j);

     // g√∂r√ºnt√ºen sanal kƒ±sƒ±mlarƒ± almak
    for ( i = 0; i < row; i++)
        for ( k=0, j = col/2; k<col/2 , j < col; k++ , j++) {
            fourier_sanal[i][k]=getPix(i, j);
        }


    Image result (row,col); // d√∂nd√ºr√ºlecek obje, inverse fourier fonksiyonu da mx2n g√∂r√ºnt√º √ºzerinden i≈ülem yaptƒ±ƒüƒ± i√ßin s√ºtun sayƒ±sƒ± deƒüi≈ütirilmemi≈ütir


    // real son√ßlar i√ßin , g√∂r√ºnt√ºn√ºn_real_kƒ±sƒ±mlarƒ± x H_uv    x=√ßarpma i≈ülemi
     for(i=0;i<row;i++)
        for(j=0;j<col/2;j++)
            result.setPix(i,j,round (fourier_real[i][j]*h_uv[i][j]));
    //sanal sonu√ßlar  ,  g√∂r√ºnt√ºn√ºn_sanal_kƒ±sƒ±mlarƒ± x H_uv     x=√ßarpma i≈ülemi
    for(i=0;i<row;i++)
        for(j=col/2,p=0; p<col/2, j<col; p++,j++) // j sadece result i√ßin, √ß√ºnk√º fourier ve h_uv dizilerinin s√ºtun sayƒ±sƒ± result objesinin s√ºtun sayƒ±sƒ±nƒ±n yarƒ±sƒ± kadar.
            result.setPix(i,j, round( fourier_sanal[i][p]*h_uv[i][p]));

    /*Dinamik hafƒ±za ile ayrƒ±lan alanlarƒ±n bo≈üaltƒ±lmasƒ±  */
    ////////////////////////////////////////////////////
    for ( i = 0; i < row; i++) {
         free(fourier_real[i]);
          free(fourier_sanal[i]);
          free(h_uv[i]);
    }


    free(fourier_real);
    free(fourier_sanal);
    free(h_uv);
    ///////////////////////////////////////////////////////
    return result;

 }

  //END OF YOUR FUNCTIONS //


